include ../../../../_includes/_util-fns

:marked
  ## Component Communication

  Real applications rarely use a single component to implement the entire functionality of the app. To create structured, testable 
  and maintainable applications, we'd better decompose the entire logic into a set of loosely-coupled (or decoupled) components.
  This way, we can create smaller building blocks with their own boundaries of responsibility, and compose the entire application
  from them.
  
  Generally, an Angular app is a tree of components &mdash; with the bootstrapped component as the root. Thinking about an app 
  structure as a tree, there are components that are in the same branch of the component tree &mdash; these form parent and child hierarchies
  &mdash;, and components that are not directly related: they are in different branches. Evidently, these have to communicate with each other
  to carry out the task the app is created for.
  
  As we already learned, _component_ is a pivotal concept of Angular, and it was designed with _inter-component communication_ in mind.
  We can imagine the following information flows:
  * From a parent to its child and children
  * From a child to its parent
  * Among unrelated, completely decoupled components
  
  In this chapter, we will learn 6 frequently used Angular mechanisms and techniques available for inter-component communication.
  We will also get acquainted with the tradeoffs of each mechanism, and understand the scenarios best suited for using a particular method of communication.
  Before diving deeply into the details, here is a short overview of these techniques:
  
  __#1: Parent to child communication with property binding__
  
  The `prop-value` expression of the parent is bound to the `child-prop` input property of the child. `child-prop` is updated every time when `prop-value` changes:
  
+makeExample('component-communication/ts/fragments/property-binding-intro.html')
  
:marked
  We can bind multiple properties of a single child component to the parent, and, implicitly, we can bind multiple children to the parent &mdash; 
  ie. with `ng-for`:
  
+makeExample('component-communication/ts/fragments/property-binding-intro-2.html')
  
:marked
  [Jump to details](#-1-parent-to-child-communication-with-property-binding)

:marked
  __#2: Child to parent communication with event emitting__
  
  When a child needs to communicate with its parent, it can emit an event. The parent can define  its own event handler method , and bind this method 
  to the child's output property:

+makeExample('component-communication/ts/fragments/event-binding-intro.html')
  
:marked
  Here, the child event is emitted by the `raiseMyEvent` method. The parent declares the `handleMyEvent()` method and binds it to the `child-event`
  output property of the child. Events can have arguments (here, `"Fired!"` is this argument) that can be passed to the parent.
  At the parent side `$event` represents the argument passed.
  
  [Jump to details](#-2-child-to-parent-communication-with-event-emitting)

  __#3: Child to parent communication with direct method calling__
  
  Nothing prevents us to implement our parent so that it passes a reference to itself to its children, and those use that reference
  to access their parent's methods and properties. When the parent embeds its children as content markup, we can hand the parent reference to 
  children in a trivial way like this:
  
+makeExample('component-communication/ts/fragments/parent-reference-1.html')
  
:marked
  Beside this technique, there are other ways to pass the parent reference to children, with little tricks we can even use dependency injection
  to inject the parent into the child component's constructor.
  The concrete technique does not matter: **Angular discourages this model, because it can sidestep the change detection mechanism, and so it may break
  the data flow model.**
  
  [Jump to details](#-3-child-to-parent-communication-with-direct-method-calling)

  __#4: Duplex parent/child communication through a service object__
  
  _Exemplification_

  [Jump to details](#duplex-parent-child-communication-through-a-service-object)

  __#5: Communication among unrelated components via a message bus__
  
  _Exemplification_

  [Jump to details](#communication-among-unrelated-components-via-a-message-bus)

  __#6: Parent to child communication where chidren are transposed in &mdash; using `@Query`__
  
  _Exemplification_

  [Jump to details](#parent-to-child-communication-where-chidren-are-transposed-in-mdash-using-query-)

  ### The Hero Job Board sample
  
  In this chapter, we will build a sample application that help us involve our heroes into actions when we really need their help.
  In this app, users can act on behalf of the person in need, and also on behalf of each hero. The basic workflow is the following:
  1. The person in need invites heroes to listen to job requests.
  1. When there's a decent job that requires superpower, the person in need announces a job request that is received by all heroes.
  1. Heroes can opt to undertake the job.
  1. When having received applications for the job, the person in need assigns the job the one of the responding heroes.
  1. The assigned hero is notified about winning the job, the others receive a message about losing the opportunity.
  
  Here is a screenshot of our complete application:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/app-ui-snapshot.png" alt="UI in action")
  
:marked
  Let's start, and dive into the details.
  
  ## #1: Parent to child communication with property binding
  
  Angular allows components to declare _data-bound input properties_. These are like regular component, but the value of an 
  input property takes its value from the expression bound to it. The framework automatically updates data-bound input properties
  during change detection.
  
  This is a one-way binding. As the source value changes, the destination property of the component is changed, but it does not 
  happen in the opposite direction: altering the value of the input property within the component does not affect the source.
  
  Input data binding can be used to pass data from a parent component to a single child, to all or a set of its children.
  As its name suggests, we can pass only data values with input property binding. This method is not suitable for sending messages that can be represented only
  with method calls, and it does not allow passing data from a child component to its parent.
  
  ### Establishing an input property binding
  
  The Hero Job Board application uses input data binding to pass the information about an invited hero from `HeroJobBoard` (parent) to all
  `HeroPanel` children. The `HeroJobBoard` component is the one that knows the circle of heroes to invite to listen to job requests, and it embeds 
  `HeroPanel` component instances that represent the control panel of heroes.
  
  In this scenario, `HeroPanel` declares the `hero` property as an input property, as the `@Input` decorator suggests:
  
+makeExample('component-communication/ts/src/app/invite-heroes/hero-panel.ts', null, 'invite-heroes/hero-panel.ts', {pnk: /(@Input)/g})

:marked
  Now, `HeroJobBoard` can iterate through its `invitedHeroes` collection and set up its `HeroPanel` children so that a single hero is
  assigned to each of them through the `hero` input property. As we learned before, the Angular property binding syntax 
  (property name wrapped into square brackets) is used:

+makeExample('component-communication/ts/src/app/invite-heroes/hero-job-board.ts', null, 'invite-heroes/hero-job-board.ts', {pnk: /(\[hero\])/g})
  
:marked
  The `Hero.heroes` static collection contains six heroes for demonstration purposes. When the application starts, `invitedHeroes` is empty, 
  but clicking the __Invite heroes__ button invokes `inviteHeroes()` and fills up `invitedHeroes`. According the template definition, these bindings
  are established between `HeroJobBoard` and its `HeroPanel` children:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/parent-and-children.png" alt="Input data binding")
  
:marked
  The application UI reflects this stucture:

figure.image-display
  img(src="/resources/images/devguide/component-communication/heroes-invited-ui.png" alt="Heroes are invited")
  
:marked
  ### Using `@Input`
  
  `Input` is defined in the core module of Angular, and we need to import it:
  
+makeExample('component-communication/ts/src/app/invite-heroes/hero-panel.ts', 'import', null, {blk: /(Input)/g})

:marked
  `@Input()` always must be used with parentheses:

+makeExample('component-communication/ts/src/app/invite-heroes/hero-panel.ts', 'input-def', null, {pnk: /(@Input)/g})

:marked
.alert.is-critical
  :marked
    It's easy to forget the parentheses. Our application will fail mysteriously if we do.
  
:marked
  Instead of using the `@Input()` annotation, we can use the `inputs` annotation property of `@Component()` to specify input properties.

  Using the alternative method, we could have defined the `hero` input property this way:
  
code-example(format='linenums', language='typescript').
  @Component({
    inputs: ['hero']
  })
  export class HeroPanel {
    hero: Hero;
  }

:marked
.alert.is-helpful
  :marked
    In this chapter, we are age going to use the `@Input()` annotation.
:marked
  ### The convenience of input data binding
  
  The change detection mechanism of Angular makes input data binding easy-to-use. We can utilize the input property values in expressions, too,
  and it makes displaying data simple.
  
  We have already implemented the functionality behind the __Invite heroes__ function with input data binding. The same mechanism allows us
  to implement announcing jobs. As the altered definition of `HeroPanel` shows, now it has another input property, `request`, which is used
  in the template in two expressions:

+makeExample('component-communication/ts/src/app/send-job-request/hero-panel.ts', 'component', 'send-job-request/hero-panel.ts (extract)')

:marked
  As the value of `request` changes, the value of the `class` attribute is updated, as well as the text of the `<h4>` tag through the 
  `request || 'No job announced'` expression. The `HeroJobBoard` side of the input data binding is as simple as we expect:
  
+makeExample('component-communication/ts/fragments/sending-request.ts', null, 'send-job-request/hero-job-board.ts (extract)')

:marked
  After inviting heroes, clicking the **Ask** button invokes `announceJob()` that sets the `request` property of `HeroJobBoard` &mdash; and Angular propagates the change to all 
  `HeroPanel` instances:

figure.image-display
  img(src="/resources/images/devguide/component-communication/send-job-request-ui.png" alt="Job request is sent")
  
:marked
  ## #2: Child to parent communication with event emitting
  
  Input property binding is an easy-to-use technique that works great in most parent-to-child communication scenarios. As the expression bound to
  the input property changes, the modification is immediately propagated to all children. At first sight we may think that this mechanism could be
  applied in the opposite direction, to send data from a child to its parent, Angular does not implement it.
  
  It is a deliberate design decision. Angular was designed with _unidirectional data flow_ in mind. This approach allows better performance, 
  and avoids issues coming from recursion when both communicating parties watch for property changes, and may change the same property, too.
  
  Instead of using a duplex communication channel between parent and child components, we can use two simplex channels, one from the parent to 
  a child (or children), and another one in the opposite direction, from the child to its parent. While you can use input property binding
  from parent to child, Angular offers event emitting (output event binding) for child-to-parent communication.
  
  ### Establishing output event binding
  
  The Hero Job Board application uses output event binding to sign that a hero undertakes the announced job. The `HeroPanel` component declares 
  an output property with a type of `EventEmitter`, though which &mdash; as the type name suggests &mdash; it can emit an event. The parent 
  `HeroJobBoard` component can use the output property to attach an event handler to that particular event.
  
  `HeroPanel` declares the `onJobTaken` property as an output event property, as the `@Output` decorator indicates:
  
+makeExample('component-communication/ts/src/app/take-job-event/hero-panel.ts', 'component', 'take-job-event/hero-panel.ts (extract)', {pnk: /(@Output|takeJob\(\)|onJobTaken\.next)/g})

:marked
  The `takeJob()` method invokes the `next()` method of the `onJobTaken` property, and passes the `hero` assigned to this very `HeroPanel`. 
  The argument of `next()` is the argument of the event emitted. Thanks to the strong type notation in TypeScript, `EventEmitter` is a generic type,
  so we could declare `onJobTaken` as an `EventEmitter<Hero>`. When we invoke `next`, the TypeScript compiler checks whether the event argument 
  is a `Hero` instance.
  
  To use `@Output()` and `EventEmitter`, `HeroPanel` needs to import them:
  
+makeExample('component-communication/ts/src/app/take-job-event/hero-panel.ts', 'import', null, {blk: /(Output|EventEmitter)/g})

:marked
  Now our `HeroPanel` is ready to emit its event. `HeroJobBoard` attaches its `heroTakesJob()` event handler method to the `onJobTaken` output
  property of `HeroPanel` using the output property binding &mdash; wrapping the snake-case name of the output property, `on-job-taken` into parentheses.
  In the output property binding expression is uses the `$event` identifier that represents the argument of the emitted event:
  
+makeExample('component-communication/ts/src/app/take-job-event/hero-job-board.ts', 'component', 'take-job-event/hero-job-board.ts', {pnk: /(\(on-job-taken\))/g, blk: /(heroTakesJob\(hero: Hero\))/g})

:marked
  The event argument is the `hero` property value of `HeroPanel` that is passed to the `next()` method of the `EventEmitter` instance beyond
  the `onJobTaken`. `HeroJobBoard` receives the `Hero` instance that undertakes the job, and adds it to its `respondingHeroes` collection.
  
  Now, we can invite heroes, announce job requests, and our heroes can opt to undertake the job. The `HeroJobBoard` component list responding heroes in the UI:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/take-job-ui.png" alt="Hero undertakes job")
  
:marked
  ### Using `@Output`
  
.alert.is-critical
  :marked
    **`@Output()` always must be used with parentheses.** If we forget about it, our application will fail inscrutably.
  
:marked
  Instead of decorating properties with the `@Output()` annotation, `@Component()` can be used to define output properties.
  We could have declared that `onJobTaken` is on output property by setting up the `outputs` annotation property of `@Component`:
  
+makeExample('component-communication/ts/fragments/alternative-output.ts', null, null, {pnk: /(outputs)/g})

:marked
  ### Event arguments
  
  A child component can easily identify its parent during parent-to-child communication, as it has exactly one parent. Thus when a parent 
  sets an input property, the child knows exactly the source. However, when a parent component attaches an event handler method to an
  output event of its child components, it needs to take into account that messages may be received from multiple children. It does not means
  that the parent needs to know which of its children sends the message. Nonetheless, the parent needs to know how to process the message, and
  it may depend on its source.
  
  We can pass arguments to events, and these arguments should contain all information the parent needs to know to process the child components'
  messages properly. We can use the non-generic `EventEmitter` type that allows usinf any type of event arguments. However, most events 
  &mdash; as a result of careful desing &mdash; expect well-defined arguments that can be represented with strong TypeScript types.
  
.alert.is-helpful
  :marked
    Angular encourages us to use strong event argument types whenever it's possible, as it allows us to create more maintainable and
    less error-prone code.
  
:marked
.alert.is-important
  :marked
    Nothing prevents us to create event argument types that pass back a reference to the child component instance to its parent so that the 
    parent component can use it directly. **It is a bad practice, and we can avoid it with careful design**. In the next section, 
    we will learn an antipattern of child-to-parent communication that helps us understand what's behind this recommendation.
  
:marked
  ## #3: Child to parent communication with direct method calling
  
  When a child communicates to its parent &mdash; as we learned in the previous section &mdash; the child component defines an output event property,
  and emits the event. To complete the communication scenario, the parent defines an event handler method and attaches it to the child's output event
  property. If the child has another kind of message, this whole scaffolding should be created for that message.
  
  Would not it be easier to use the good old way and pass a parent reference to each child? Yes, it's tempting, and we can do that.

.alert.is-critical
  :marked
    Although this technique works in many situations, it's an **antipattern**, and Angular discourages using it.
  
:marked
  ### Passing a parent reference to children
  
  Instead of using output event emitting, in this section our heroes will take the job by directly calling the `heroTakesJob()` method of `HeroJobBoard`.
  Because children are defined in the template markup of `HeroJobBoard`, we need a helper property, `jobBoard` that can be bound to the `parent` input
  property of `HeroPanel` (the irrelevant code and markup is omitted for the sake of brevity):
  
+makeExample('component-communication/ts/fragments/hero-job-board-with-parentref.ts', null, 'take-job-parentref/hero-job-board.ts (extract)', {pnk: /(\[parent\]|jobBoard\(\))/g})

:marked
  `HeroPanel` now has a reference to its parent, and it can easily call the `heroTakesJob()` method:
  
+makeExample('component-communication/ts/fragments/hero-panel-with-parentref.ts', null, 'take-job-parentref/hero-panel.ts (extract)', {blk: /(HeroJobBoard)/g, pnk: /(parent|takeJob\(\)|heroTakesJob)/g})

:marked
  ### Why this practice is bad
  
  There are two main reasons we should avoid this pattern:
  * It may break Anngular's data flow
  * It may raise architectural issues
  
  Angular has a robust change detection mechanism that assumes that component communication goes through boundaries controlled by the framework. 
  When an input property is set or an event handler method is invoked, the framework is in control, the change detection mechanism can recognize changes and
  propagate them through the affected components. If a child calls a parent method, and it happens while the change detection mechanism, that will definitely
  break the data flow model. It may result unexpected application behavior and may lead to misterious results. Once we have a reference to the parent, it's 
  difficult to resist the temptation...
  
  In this section, we used tightly-coupled binding between an `HeroPanel` instance and its parent, `HeroJobBoard`. This design may hurt the autonomy 
  of both component types, and does not help a real separation of responsibilities. Instead of simply notifying `HeroJobBoard` and trust in that it can administer 
  the list of responding heroes, `HeroPanel` takes over this task, and invokes the `heroTakesJob()` method directly.
  
  By passing a reference to itself, `HeroJobBoard` offers its entire functionality to an `InvitedHero` instance. This way nothing can prevent `InvitedHero` to use
  other `HeroJobBoard` operations, for example, it could invoke even `announceJob()`, and that hurts our workflow design as badly as the autonomity of components. Giving up
  the fundamental desing principles based on properly used and clean component decomposition prevents us from creating easily maintainable and testable software,
  and creates technical debt.
  
  ## #4: Duplex parent/child communication through a service object
  
  _Content_

  ## #5: Communication among unrelated components via a message bus
  
  _Content_

  ## #6: Parent to child communication where chidren are transposed in &mdash; using `@Query`
  
  _Content_
  
  ## Conclusion
  
  _Content_

 
  ## __Do not review the subsequent sections!__ _Everything from here is old content to be removed_
  
  ## #5: A hero takes the job &mdash; child to parent communication with events
  
  Knowing that the the tight coupling we used in the previous scenario is an antipattern, it's time to learn how we can avoid such a situation with Angular.
  
  The task we want to solve correctly is that `InvitedHero` needs to notify its parent `HeroJobBoard` that a hero undertaks the requested job so that the hero can be 
  added to the list of responding ones. We will use _event binding_ to communicate from a children to its parent. We create an _output property_ on `InvitedHero`, 
  and in the template of `HeroJobBoard` &mdash; where `InvitedHero` is specified with the `<invited-hero>` element &mdash; we bind the output property to a
  `HeroJobBoard` event handler method.
  
  We can easily add an output property to `InvitedHero`. We name this new property `onHeroResponse`, and use it within the `undertakeJob()` method:
  
+makeExample('component-communication/ts/take-job-event/src/app/invited-hero.ts', 'component', 'invited-hero.ts', {blk: /(onHeroResponse|undertakeJob\(\))/g})

:marked
  We annotated the output parameter with the `@Output()` decorator, and initialized it to a new `EventEmitter<Hero>` instance.
  
.alert.is-important
  :marked
    Again, do not forget to use the parentheses with `@Output()` so that our application would not fail mysteriously.
:marked
  In order to use these new types, we must import them from the core Angular module:
  
+makeExample('component-communication/ts/take-job-event/src/app/invited-hero.ts', 'import', null, {blk: /(Output|EventEmitter)/g})

:marked
  Being an output parameter means that an external component can bind an event handler method in its template that responds the event raised with the object
  behind the output parameter. As the body of `undertakJob()` shows, we can notify the event that a hero undertook the job through calling 
  `this.onHeroResponse.next(this.hero)`. The `onHeroResponse` property's type is `EventEmitter<Hero>`. As its name suggest, an instance of this type can emit events 
  that are represented with arguments of type `Hero`. In our very case, with the event we pass the `Hero` instance that undertook the job.
  
.alert.is-helpful
  :marked
    The `EventEmitter` generic type is built on the features of the `Observable` type of ECMAScript standard library. `Observable` is a type that
    can be used to model push-based data sources such as DOM events, timer intervals, and sockets. Understanding this type requires a detailed discussion,
    and in this chapter we are not going to leverage the features of observables.
    
    `EventEmitter` can be used not only for output parameters, but in other publish-subscribe scenarios, as we will learn it soon.
:marked
  `HeroJobBoard` can bind itself to the `onHeroResponse` event:
  
+makeExample('component-communication/ts/take-job-event/fragments/invited-hero.html', null, 'hero-job-board.ts (extract from template)', {blk: /(\(on-hero-response\))/g})

:marked
  The event is bound to the `heroTakesJob()` method, and `$event` represents the `Hero` instance passed by `InvitedHero` as the event argument, which is the hero who
  undertook the job. The `heroTakesJob()` method is exactly the same as we used in the previous scenario:
  
+makeExample('component-communication/ts/take-job-event/src/app/hero-job-board.ts', 'hero-takes-job', 'hero-job-board.ts')

:marked
  Now, with these simple steps, our app works just like at the end of the previous scenario &mdash; but this time it uses a supported child-to-parent communication pattern.
  
  ### Why this practice is preferred
  
  In this scenario, out components kept their autonomy, in constrast to the antipattern treated in the previous scenario. `InvitedHero` gets the job request through an
  input property, but actually does not know from which component the job request is bound to its `request` property. Similarly, when a hero undertakes the job, 
  `InvitedHero` emits an event through its `onHeroResponde` output property without knowing which component (or components) listen to this event.
  
  This architecture allows easy maintenance and testing, as our components encapsulate everything they are responsible for. They do not have strong dependencies on 
  other components. When we face with child-to-parent communication, using events as we did in this scenario is a _viable way to avoid the traps and fragility_ of the
  antipattern demonstrated in the previous section.
  
  ## #6: Refactoring communication to an intermediary service
  
  There is still a tiny flaw in our inter-component communication design. The `HeroJobBoard` and `InvitedHero` components are autonomous but they need to communicate
  directly with each other to implement the applications. In its current form, `InvitedHero` implements only UI logic, but `HeroJobBoard` mixes UI logic &mdash; 
  logic that controls the appearance and state of the UI &mdash; with business logic &mdash; the logic that adminsters the state of the job board management workflow.
  
  In a real application the job requests, the heroes' applications for the job and assigments were persisted somewhere at the backend, and certain business rules
  were enforced. To move toward a more flexible and more real architecture, the business logic that is encapsulated right now into `HeroJobBoard` should be moved 
  into a separate entity &mdash; let's call it `JobService`. Instead of communicating directly with each other, `HeroJobBoard` and `InvitedHero` instances would trust
  in `JobService` to manage the business logic, and our componenst would manage only the state of the UI they are responsible for.
  
  In this scenario, we will refactor our app by adding the new `JobService` component. Our design will use different communication, as indicated by the dashed arrows 
  (solid arrows still indicate parent-child relationships):
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/jobservice-communication.png" alt="Adding JobService")
  
:marked
  Let's implement the new intermediary service, `JobService`: 
  
+makeExample('component-communication/ts/job-service/src/app/job-service.ts', null, 'job-service.ts')

:marked
  The structure of this component is pretty straightfoorward: internally it uses the `_jobRequest` and `_respondingHeroes` members to store the state of the 
  Hero Job Board workflow. It exposes the state of the component through the `jobRequest` and `respondingHeroes` getters, and provides two operations, `post()` for
  announcing new job requests, and `take` to let heroes undertake the job. Beside these methods, the `jobPostEvent` event emitter can be used to subscribe for new
  job request events.
  
.alert.is-helpful
  :marked
    Observe, `JobService` has an annotation, `@Injectable()`, which is used to create metadata for `JobService` so that we can inject it into other components. 
    We treated this mechanism in the [Dependency Injection](./dependency-injection.html#when-the-service-needs-a-service) chapter with more details.
:marked
  Now, let's alter `HeroJobBoard` to leverage `JobService`:
  
+makeExample('component-communication/ts/job-service/src/app/hero-job-board.ts', 'component', 'hero-job-board.ts (component)')

:marked
  The structure of `HeroJobBoard` did not change much. Instead of its own data members, now it uses the properties and operations available through the `JobService`
  instance that has been injected through the `HeroJobBoard` constructor. Soon, we will learn how dependency injection works in this scenario.
  
  We can easily utilize `JobService` in `InvitedHero`:
  
+makeExample('component-communication/ts/job-service/src/app/invited-hero.ts', 'component', 'invited-hero.ts (component)')

:marked
  We still pass the `hero` property from `HeroJobBoard` via data binding, but not `request` anymore. Observe how we use the `subscribe` method of the injected 
  `JobService` to define an event handler for the `jobPostEvent` event. `jobPostEvent` accepts a string (the event is defined as an `EventEmitter<string>`), 
  which contains the job request. So, any time a new job request arrives, the `InvitedHero` instance updates its state (and the UI) accordingly.
  
.alert.is-helpful
  :marked
    Because both component utilize `JobService`, it needs to be imported in `hero-job-board.ts` and `invited-hero.ts`.
:marked
  Our application will work properly only if we use a singleton instance of `JobService`: the single `HeroJobBoard` instance and all `InvitedHero` instances 
  _must use_ the very same `JobService` instance. We'll ensure this behavior by configuring `HeroJobBoard`'s `providers` annotation property this way:
  
+makeExample('component-communication/ts/job-service/fragments/provider-annotation.ts', null, 'hero-job-board.ts (component annotation)', {blk: /(providers)/g})

:marked
  Thanks to the great design of Angular's hierarchical dependency injection system &mdash;
  it supports nested injectors in parallel with the component tree &mdash; `InvitedHero` instances automatically obtain the same `JobService` instance injected
  through their constructor as `HeroJobBoard` gets.
  
  When we run our app, it still works exactly as in the previous scenario. We can invite heroes, announce job requests, and heroes can undertake them. 
  It's time to add the last step of the basic workflow so that the person in need can assing the job to the hero who deserves it the best.
  
  ## #7: Assigning the job to a hero &mdash; extending the intermediary service
  
  Now, we have the `JobService` component, which &mdash; according to our intention &mdash; encapsulates the business logic of the app. Naturally, we want this
  very component to implement the method of assigning the job to a hero. We need to provide a method for `HeroJobBoard` to assign the job to one of the responding
  heroes, and add an event `InviteddHero` instances listen to in order to get notified about job assignment.
  
  This extension is strightforward, as the new, highlighted members of `JobService` show:
  
+makeExample('component-communication/ts/assign-job/src/app/job-service.ts', null, 'job-service.ts', {blk: /(_assignedTo|assignedTo\(\)|jobAssignedEvent|assign\(hero: Hero\))/g})

:marked
  To integrate the new `assign()` method with `HeroJobBoard`, we need to change the component template and add a couple of methods to the class body, as shown in
  this code extract:
  
+makeExample('component-communication/ts/assign-job/fragments/hero-job-board.ts', null, 'job-service.ts', {blk: /(winner\(\)|assignJob\(hero: Hero\))/g})
  
:marked
  Now, the component template removes the list of responding heroes as soon as the job as assigned to one of them, and the winner is displayed in the Hero Job Board.
  We need to change `InvitedHero`, too, so that it could listen to assignment announcements, and change its UI accordingly:
  
+makeExample('component-communication/ts/assign-job/fragments/invited-hero.ts', null, 'invited-hero.ts', {blk: /(subscribe|finalState\(\))/g})
  
:marked
  Here, `InviteHero` subscribes to the `jobAssignedEvent`, and sets the winner hero according to the event parameter (`JobService` defines `jobAssigned` as a 
  type of `EventEmitter<Hero>`). The `finalState()` helper method is used to set the right label in the UI of the component that displays 
  whether the hero won or lost &mdash; provided it undertake the job at all.
  
  When the person in need assigns a job to a hero, the UI is immediately updated. This figure shows that Mr. Nice, Bombasto and RubberMan undertook the job,
  and finally it was assigned to Bombasto:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/assign-job-ui.png" alt="Assign a job to a hero")
  
:marked
  Now, we implemented the basic workflow. We could have been satisfied with the component communication scenarios we've implemented by now, but there's still a
  few things that we should discuss.
  
  ## #8: A malicious hero steals the job &mdash; issues with multiple facades
  
  With moving the business logic to `JobService`, we made a great design decision, as we can manage business and UI logic separately. However the _way we use_
  `JobService` has a flaw. Right now both `HeroJobBoard` and `InvitedHero` use a single facade to access `JobService` functionality, and through this facade
  these components can access all operations, and not only the ones intended for their use. The following blueprint shows how the members of `JobService` are used:
  
code-example(format='linenums', language='typescript').
  export class JobService {
      get jobRequest();         // HeroJobBoard
      get respondingHeroes();   // HeroJobBoard
      get assignedTo();         // HeroJobBoard
    
      jobPostEvent;             // HeroJobBoard and InvitedHero
      jobAssignedEvent;         // HeroJobBoard and InvitedHero
    
      post(jobRequest: string); // HeroJobBoard
      take(hero: Hero);         // InvitedHero
      assign(hero: Hero);       // HeroJobBoard
  }

:marked
  This design allows that components can invoke operations that were not available for them with properly designed facades. We'll it by adding a new `stealJob()` method
  to `InvitedHero` so that a hero can maliciously steal a job assigned to another hero:
  
+makeExample('component-communication/ts/steal-job/src/app/invited-hero.ts', 'steal', 'invited-hero.ts')
  
:marked
  Let's append this markup snippet to the template of `InvitedHero` so that we can invoke `stealJob()` from the UI:
  
+makeExample('component-communication/ts/steal-job/fragments/steal.html', null, 'invited-hero.ts (template)')
  
:marked
  Now, an `InvitedHero` instance can behave as if it were `HeroJobBoard` and invoke the `assign()` method of `JobService`, passing itself as the winner hero.
  
  When we run the application, after the job is assigned to a hero, all other heroes (even those who have not undertaken the job before) can click the **I steal the job!**
  button and scrounge the job. This screenshot shows that Magneta has been assigned the job:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/winner-announced-ui.png" alt="The winner is announced")
  
:marked
  Now, Bombasto can use the **I steal the job button!**, and the job goes to him. (It's not a great consolation for Magneta that she can steal the job back...)
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/job-stolen-ui.png" alt="The job is stolen")
  
:marked
.alert.is-important
  :marked
    After a short by-pass (in the next scenario), we'll go on with the code we created in this scenario, so it is worth to make a backup 
    so that we can return to it easily.
    
:marked
  ## #9: Preventing stealth &mdash; using multiple facades
  
  Let's fix the issue with `JobService`! If we'd have two separate facades, one for `HeroJobBoard` and another for `InvitedHero`, we would not have this issue.
  There are several ways to create two facades that use the same service object in the background. One way is to create two objects &mdash; each with the appropriate
  facade &mdash;, and aggregate the singleton `JobService` instance with them. Implictly, these objects would expose only these `JobService` operations that are 
  required by their facade.
  
  We will apply this method &mdash; with a little twist. We are going to leverage on two great TypeScript features:
  1. Abstract classes (more details [here](https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#abstract-classes-and-methods))
  1. TypeScript allows to use classes as if those were interfaces (more details [here](http://www.typescriptlang.org/Handbook#classes-advanced-techniques)) 
  
  Here is the revised map of object communication. It leverages the refactored version of `JobService`, which now provides two facades, 
  `JobBoardFacade` and `InvitedHeroFacade`, respectively:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/job-service-facades.png" alt="Communication through new facades")
  
:marked
  Now let's see how these changes are represented in the code of `JobService`:
  
+makeExample('component-communication/ts/prevent-stealth/src/app/job-service.ts', null, 'job-service-ts', {blk: /(JobService|JobBoardFacade|InvitedHeroFacade)/g})
  
.alert.is-important
  :marked
    Although our suggested convention is to create one class per file &mdash; as treated in [Dependency Injection's Appendix](./dependency-injection.html#appendix-why-we-recommend-one-class-per-file)
    &mdash; this code is an exception for the sake of easier discussion.
    
:marked
  We declare `JobBoardFacade` and `InvitedHeroFacade` as abstract classes, and mark all of their operations as `abstract`. We altered the definitions of 
  `jobPostEvent` and `jobAssignedEvent` from a property getter to a function, since property getters cannot be abstract.
  
  Just as many "curly brace" languages, TypeScript does not support multiple inheritance. Of course, it supports implementing multiple interfaces. We utilize the
  TypeScript feature that it can handle classes as if those were interfaces: we declare `JobService` so that it _implements_ both `JobBoardFacade` and `InvitedHeroFacade`.
  
  To make `HeroJobBoard` use `JobBoardFacade` and `InvitedHero` to work with `InvitedHeroFacade`, we need to change the constructors of these classes:
  
code-example(format='linenums', language='typescript').
  // hero-job-board.ts:
  export class HeroJobBoard {
      constructor(private jobBoardFacade: JobBoardFacade) {
          // ...
      }
      // ...
  }

  // invited-hero.ts:
  export class InvitedHero {
      // ...
      constructor(private heroJobFacade: InvitedHeroFacade) {
          // ...
      }
  }

.alert.is-important
  :marked
    Evidently, we need to rename the local `jobService` property names in `HeroJobBoard` to `jobBoardFacade`, and in `InvitedHero` to `heroJobFacade` to
    make the code sample work. 
    
:marked
  We have one more task to complete: we have to change dependency injection so that a _singleton_ `JobService` instance will be injected to the single 
  instance of `HeroJobBoard` and the multiple instances of `InvitedHero`. We'll do this by changing the `directives` annotation property on `HeroJobBoard`:
  
code-example(format='linenums', language='typescript').
  import {Component, provide, CORE_DIRECTIVES} from 'angular2/angular2';
  import {InvitedHero} from './invited-hero';
  import {JobService, JobBoardFacade, InvitedHeroFacade} from './job-service';
  import {Hero} from './hero';
  
  let jobService = new JobService();

  @Component({
      /* ... */ 
      providers: [
          provide(JobBoardFacade, {useValue: jobService}),
          provide(InvitedHeroFacade, {useValue: jobService})
      ]
  })
  export class HeroJobBoard {
      // ...
  }

:marked
  Right at the very beginning of the module, we create the single `JobService` instance, `jobService`. Because `JobService` implements both 
  `JobBoardFacade` and `InvitedHeroFacade`, we can configure the injector to use the single instance of `jobService` to represent both facades.
  To achive this, we utilize the `provide()` function with the `useValue` configuration property.
  
  ### Why we cannot use `stealJob()` now
  
  Now, the `InvitedHeroFacade` does not offer the `assign()` method, so when you try to compile the `invited-hero.ts` file, the TypeScript compiler raises an error:
  
code-example(language='text').
  src/app/invited-hero.ts(114,28): error TS2339: Property 'assign' does not exist on type 'InvitedHeroFacade'.

:marked
  When we work with an editor that has IntelliSense (Such as Sublime or Visual Studio Code), we cannot find `assign()` on the list of available members for
  `heroJobFacade`:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/assign-is-not-offered.png" alt="heroJobFacade members")
  
:marked
  So, using separate facades to expose the services of the singleton `JobService` objects helped us to prevent issues coming from a flaw in the component design.
  
  ## #10: Broadcasting messages &mdash; parent and child communicates with an unrelated component
  
  By now, we discussed different ways to communicate between components within the same tree of components, from parent to children, from a child to its parent.
  We examined how intermediary components (services) can be used, and also analyzed potential desing flaws and trade-offs. In this scenario, we demonstrate how 
  unrelated components can communicate with each other. 
  
  Most of our heroes are extravert, and like to win &mdash; and definitely are hurt by losing in any plight. In this scenario, we let them brag or complain when they win
  or lose a job, and steal jobs for the winners. We do this for the sake of introducing a new component, `MessageBus` that can be flooded with messages coming from 
  heroes and the person in need. To check the messages poured on `MessageBus` &mdash; int this scenario &mdash; we will use the console log. 
  
.alert.is-important
  :marked
    In this scenario, we start from the application version completed and backed up at the end of [A malicious hero steals the job](#-8-a-malicious-hero-steals-the-job-mdash-issues-with-multiple-facades)
    section.
    
:marked
  The `MessageBus` component is very simple, it declares a single `broadcastMessage()` method:

+makeExample('component-communication/ts/message-bus/src/app/message-bus.ts', null, 'message-bus.ts')
  
:marked
  To leverage `MessageBus` in `HeroJobBoard`, we pass a `MessageBus` instance in the constructor, and append the call of `broadcastMessage()` to `inviteAllHeroes()`,
  `announceJob()` and `assignJob()`:

code-example(format='linenums', language='typescript').
  export class HeroJobBoard{
      constructor(private jobService: JobService,
          private messageBus: MessageBus) {
          jobService.post(null);
      }
      // ...
      
      inviteAllHeroes() {
          // ...
          this.messageBus.broadcastMessage('Heroes invited.');
      }
      
      // ...
      announceJob(request) {
          // ...
          this.messageBus.broadcastMessage('Job announced: ' + request.trim());
      }
    
      assignJob(hero: Hero) {
          this.messageBus.broadcastMessage('Job "' + this.jobRequest 
              + '" assigned to ' + hero.name);
      }
  }

:marked
  Similarly, we inject `MessageBus` into `InvitedHero`, and invoke `broadcastMessage()` in `undertakeJob()` and `stealJob()`:
  
code-example(format='linenums', language='typescript').
  export class InvitedHero {
      // ...
      constructor(private jobService: JobService,
          private messageBus: MessageBus) {
          // ...
      }
      // ...
      
      undertakeJob() {
          // ...
          this.messageBus.broadcastMessage('*** I, ' + this.hero.name
            + ', proudly undertake the job!')
      }
    
      stealJob() {
          this.messageBus.broadcastMessage('*** I, ' + this.hero.name
              + ', stole the job... Hahaha...');
      }
  }

:marked
  In order `HeroJobBoard` and `InviteHero` instances can access the `MessageBus` instance, we need to add it to the `providers` annotation 
  property of `HeroJobBoard`:
  
+makeExample('component-communication/ts/message-bus/src/app/hero-job-board.ts', 'providers', 'hero-job-board.ts', {blk: /(MessageBus)/g})
  
:marked
  Just as `JobService`, the `MessageBus` instance is injected into the constructors of `InvitedHero` instances by Angular, as they are the 
  children of the single `HeroJobBoard` instance.
  When we run the app, `MessageBus` shows the activity in the console log:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/message-bus-ui.png" alt="Messages in the console")
  
:marked
  ## #11: Message Board &mdash; receiving messages from an unrelated component
  
  It's great that we can log messages, but it would be great to show them on UI of the Her Job Board application. Let's create a new component,
  `MessageBoard`, which displays messages sent to `MessageBus`. Our `MessageBus` component is generic, although right now it accepts messages 
  only from `HeroJobBoard` and `InvitedHero`, it can receive messages from any other app. When we create `MessageBoard`, we rather nest it into
  `HeroJobApp` instead of `HeroJobBoard` so that later messges from application components outside of the `HeroJobBoard` subtree can be displayed, too.
  The hierarchy and communication of the app components (excluding `JobService` for the sake of simplification) now looks like this:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/message-board-communication.png" alt="Message board")
  
:marked
  Let's change the `MessageBus` component so that it will raise an event any time a new message is received &mdash; while still writing the message
  to the console log:
  
+makeExample('component-communication/ts/message-board/src/app/message-bus.ts', null, 'message-bus.ts', {blk: /(messageReceived)/g})
  
:marked
  Now we can add create the `MessageBoard` component that listens to the `messageReceived` event of `MessageBus`, appends the new message to
  its internal store, and displays it. Evidently, `MessageBoard` depends on `MessageBus`, and we resolve this dependency with constructor injection:
  
+makeExample('component-communication/ts/message-board/src/app/message-board.ts', null, 'message-board.ts')
  
:marked
  Now, let's modify `app.ts`, to add `MessageBoard` to the UI. We add this component deliberately to `HeroJobApp` and not to `HeroJobBoard`:
  
+makeExample('component-communication/ts/message-board/fragments/app-1.ts', null, 'app.ts', {pnk: /(&lt;message-board&gt;)/g})
  
:marked
  At this point, we have every component on its right place. However, when we run the app, we get an Angular error message in the console log of the browser:
  
code-example(language='text').
  EXCEPTION: No provider for MessageBus! (MessageBoard -> MessageBus)

:marked
  This error points out to an important fact: Angular could not inject `MessageBus` into the `MessageBoard` constructor. Previously we were indulged,
  because dependent object injected to `HeroJobBoard` were inherited by child components. But `MessageBoard` is not in the `HeroJobBoard` subtree, so
  it cannot obtain the `MessageBus` instance we injected to `HeroJobBoard`.
  
  The solution is simple: we need to inject `MessageBus` into `HeroJobApp`:
  
code-example(format='linenums', language='typescript').
  // ...
  import {MessageBus} from './message-bus';

  @Component({
      // ...
      providers: [MessageBus]
  })
  class HeroJobApp { }

  bootstrap(HeroJobApp);

:marked
  When we run the app, messages are displayed in the console log, but they are not shown in `MessageBoard`. Did we still miss something? The console log
  does not indicate any Angular or other issue.
  
  The cause of the phenomenon is that we forgot to remove `MessageBus` from `providers` in `hero-job-board.ts`.
  
code-example(format='linenums', language='typescript').
  @Component({
      // ...
      providers: [JobService, MessageBus]
  })
  export class HeroJobBoard{
      // ...
  }
  
:marked
  When we run the app, there are two `MessageBus` instances. One is used by `MessageBoard` &mdash; it listens to messages &mdash; and another 
  in the `HeroJobBoard` subtree. Messages are sent to the second instance, but `MessageBoard` listens to the first.
  
  To resolve the issue, we simply remove `MessageBus` from the provider list in `HeroJobBoard`. Now, the message board works exactly as we expect:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/message-board-ui.png" alt="Message board")
  
:marked
  ## Conclusion
  
  Angular provides great communication mechanisms among components within an application. If we have components within the same tree or subtree,
  we have parent and child components, and can use these methods:
  * **Parent to child**: data binding with using one or more `@Input()` propery in the child component, the values of which can be assigned in the parent's 
  template.
  * **Child to parent**: event binding with using one or more `@Output()` properties (`EventEmitter` instances) in the child component, the event handlers 
  of which can be assigned in the parent's template.
  
  If we have have unrelated components that are in separate subtrees, they can communicate **through intermediary components**, such as services:
  * The same intermediary component instance can be injected into the the communicating parties. 
  * The parties utilize the intermediary component, 
    * they can access its properties, 
    * invoke its methods,
    * and subscribe to its events.
    
  As we discussed, intermediary components are great alternatives for parent to child, and child to parent communication, too.
  
  In this chapter, we identified a few issues Angular developers should be aware of when designing and implementing inter-component communication:
  * Using a direct reference to the parent component in a child to parent communication scenario &mdash; ie. by passing down the reference
  through data binding &mdash; is an **antipattern**. It makes the app less testable and maintainable, and makes it fragile.
  * When working with intermediary communication components, we need to take care of designing the communication facades. We should expose only those operations to 
  communicating parties that they need to use, and disallow invoking operations intended to be utilized only by other communication parties.
