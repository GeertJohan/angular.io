include ../../../../_includes/_util-fns

:marked
  ## Component Communication

  Generally, an Angular app is a tree of components &mdash; with the bootstrapped component in its root. Thinking of an app's 
  structure as a tree, there are components that are in the same branch of the component tree &mdash; these form parent and child hierarchies
  &mdash;, and components in different branches &mdash; they are not directly related. Evidently, components need to communicate with each other
  to carry out the tasks the app is created for.
  
  As we already learned, _component_ is a pivotal concept of Angular, and it was designed with _inter-component communication_ in mind.
  We can think of the following information flows:
  * from a parent to its children
  * from a child to its parent
  * among unrelated, completely decoupled components
  
  In this chapter, we learn five frequently used Angular mechanisms and techniques available for inter-component communication.
  We also get acquainted with the tradeoffs of each mechanism, and understand the scenarios best suited for using a particular method of communication.
  Before diving deeply into the details, here is a short overview of these techniques:
  
  __#1: Parent to child communication with input property binding__
  
  The value of the `aHero` local variable of the parent is bound to the `hero` input property of the child. `hero` is updated every time when `aHero` changes:
  
+makeExample('component-communication/ts/app/invite-heroes/job-board-template.html', 'input-binding')
  
:marked
  [Jump to details](#-1-parent-to-child-communication-with-input-property-binding)

:marked
  __#2: Child to parent communication with event emitting__
  
  When a child needs to communicate with its parent, it can emit an event. The parent can define its own event handler method that responds
  to the child's event.

+makeExample('component-communication/ts/app/take-job-event/job-board-template.html', 'event-binding', null, {pnk: /(onJobTaken)/g} )
  
:marked
  Here, any time the child raises its `onJobTaken` event, the parent's `heroTakesJob()` method is called with the event argument 
  &mdash; `$event` &mdash; the child provides.
  
  [Jump to details](#-2-child-to-parent-communication-with-event-emitting)

  __#3: Duplex parent/child communication through a service object__
  
  Parent and child components share their responsibilities, including UI logic and others. They can delegate the shared state management
  to a service. Instead of talking directly with each other, both the parent and the child can communicate about that state through
  the service.
  
code-example(format="linenums" language="javascript").
  @Injectable()
  export class JobService {
    // ...
  }
  
:marked
  This service is injected into the parent and child components via Angular dependency injection (via component constructors):

code-example(format="linenums" language="javascript").
  @Component({
    selector: 'hero-job-board',
    template: `
      &lt;hero-panel *ngFor='#aHero of invitedHeroes'&gt;
      &lt;/hero-panel&gt;
    `,
    providers: [JobService]
  })
  export class HeroJobBoard {
    constructor(private jobService: JobService){
      // ...
    }
    // ...
  }
  @Component({
    selector: 'hero-panel'
    // ...
  })
  export class HeroPanel {
    constructor(private jobService: JobService){
      // ...
    }
    // ...
  }

:marked
  Both component types can access the service instance injected into the constructor. The dependency injection mechanism takes care 
  that the parent component instance and its children share a single instance of `CommService`.
  
  [Jump to details](#-3-duplex-parent-child-communication-through-a-service-object)

  __#4: Communication among unrelated components via a message bus__
  
  The communicating components aren't always in a parent-child relationship. They can be siblings or they can be in distant
  branches of the application component hierarchy. In such scenarios, components can communicate with each other
  through intermediary object.
  
  In this chapter, we create a message bus that is used as a common communication channel among totally unrelated components.
  for sending and listening to messages. We use the same approach to create the message bus service as we do it with `JobService`.
  However, we need a different method to inject message bus service into the communicating components to provide that all of them are
  using the very same message buse instance &mdash; as they are unrelated.
  
  [Jump to details](#-4-communication-among-unrelated-components-via-a-message-bus)

  __#5: Parent to child communication where children are transposed in &mdash; using `@ContentChildren`__
  
  Often, we define nested content in a parent component's definition:
  
+makeExample('component-communication/ts/fragments/contentchildren-intro.html')

:marked
  Here,`child-content` is just a directive that defines content:
  
+makeExample('component-communication/ts/fragments/contentchildren-intro.ts', 'child-content')

:marked
  We'd like to render a view so that a particluar component, ie. `ChildComponent`, is used for each `child-content`:
  
+makeExample('component-communication/ts/fragments/contentchildren-intro.ts', 'child-comp')

:marked
  Somehow, we need to transpose the `child-content` elements into `parent-comp` as `ChildComponent` instances, and want to communicate
  from the parent component to its children. We know that input data binding is a simple and great way to implement parent-to-child 
  communication so that we'd like to apply a template like this, where `myContent` represents the collection of `child-content` elements we
  nested into `parent-comp`:
  
+makeExample('component-communication/ts/fragments/contentchildren-intro.ts', 'parent-comp-def', null, {pnk: /(myContent)/g})

:marked
  The issue is that we do not know how to get a collection of `child-content` elements and store them in `myContent` so that we
  can iterate through this collection, define the child component instances, and establish the input property binding.
  
  Angular provides the `@ContentChildren` annotation we can use to define that we need to get a collection of children that are used
  as content within our parent component. The framework takes care of initializing this collection during component instantiation, 
  detects changes, and dynamically updates the collection of children:
  
+makeExample('component-communication/ts/fragments/contentchildren-intro.ts', 'parent-comp', null, {pnk: /(@ContentChildren)/g})

:marked
  [Jump to details](#-5-parent-to-child-communication-where-children-are-transposed-in-mdash-using-contentchildren-)

  ### The Hero Job Board sample
  
  In this chapter, we build a sample application that help us involve our heroes in actions when we really need their help.
  In this app, users can act on behalf of the person in need, and also on behalf of each hero. The basic workflow is the following:
  1. The person in need invites heroes to listen to job requests.
  1. When there's a decent job that requires superpower, the person in need announces a job request that is received by all heroes.
  1. Heroes can opt to undertake the job.
  1. When having received applications for the job, the person in need assigns the job to the one of the responding heroes.
  1. The assigned hero is notified about winning the job, the others receive a message about losing the opportunity.
  
  Here is a screenshot of our complete application:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/app-ui-snapshot.png" alt="UI in action")
  
:marked
  ### Live Example
  
  The application is available as a live example. In this app we are implementing Hero Job board scenarios, each of them
  illustrating one of the aforementioned techniques. A few scenario covers the entire workflow, while others implement only a 
  few steps.
  
  We use the router to make it easy to hop among the illustrations. Each scenario we present has a link in the headline of the app.
  When treating a specific technique, we name the link that leads to the corresponding sample.
  
  [Live Example](/resources/live-examples/component-communication/ts/plnkr.html)
  
  Let's start, and dive into the details!
  
  ## #1: Parent to child communication with input property binding
  
  Angular allows components to declare _data-bound input properties_. These are like regular component, but the value of an 
  input property takes its value from the expression bound to it. The framework automatically updates data-bound input properties
  during change detection.
  
  This is a _one-way binding_. As the source value changes, the destination property of the component is changed. When we change the
  value of the input property in the child, the property's value does not flow back to the parent.
  
  Input data binding can be used to pass data from a parent component to a single child, to all or a set of its children.
  As its name suggests, we can pass only data values with input property binding. This method is not suitable for sending messages that can be represented only
  with method calls, and this mechanism does not allow passing data from a child component to its parent.
  
  ### Establish an input property binding
  
  To create an input property binding, we need to carry out these steps:
  1. Adding an input property to the child component (apply the `@Input()` decorator on the particular property)
  1. Using this property with the _input binding syntax_ in the parent template to bind it to an expression
  
  The Hero Job Board application uses input data binding to pass the information about an invited hero from `HeroJobBoard` (parent) to all
  `HeroPanel` children. The `HeroJobBoard` component is the one that knows the circle of heroes who should be invited to listen to job requests, and it embeds 
  a `HeroPanel` component instance for each hero.
  
  In this scenario, `HeroPanel` declares an input property, `hero`, as the `@Input()` decorator suggests:
  
+makeExample('component-communication/ts/app/invite-heroes/hero-panel.ts', null, 'invite-heroes/hero-panel.ts', {pnk: /(@Input\(\))/g})

:marked
  `HeroJobBoard` iterates through its `invitedHeroes` collection and sets up its `HeroPanel` children so that a single hero is
  assigned to each of them through the `hero` input property. We use Angular property binding syntax 
  (property name wrapped into square brackets) to pass the current iteration hero to the child component:

+makeExample('component-communication/ts/app/invite-heroes/job-board-template.html', null, 'invite-heroes/job-board-template.html', {pnk: /(\[hero\])/g})

:marked
  When the application starts, `invitedHeroes` is empty, but clicking the __Invite heroes__ button invokes `inviteHeroes()` and 
  fills up the `invitedHeroes` array from the `Hero.heroes` static collection:
+makeExample('component-communication/ts/app/invite-heroes/hero-job-board.ts', null, 'invite-heroes/hero-job-board.ts', {pnk: /(inviteHeroes\(\))/g})
  
:marked
  According the template definition, these bindings are established between `HeroJobBoard` and its `HeroPanel` children:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/parent-and-children.png" alt="Input data binding")
  
:marked
.alert.is-helpful
  :marked
    We can access this sample through the `Invite` link.
:marked
  When we run the app and click the **Invite heroes** button, the application UI reflects this stucture:

figure.image-display
  img(src="/resources/images/devguide/component-communication/heroes-invited-ui.png" alt="Heroes are invited")
  
:marked
  ### Can we change and alter an input property in the child component?
  
  As we mentioned earlier, when the `hero` property (the source expression) changes in `HeroJobBoard` (parent), the `Hero`
  input property of `HeroPanel` (destination) changes accordingly. In contrast, if we'd change `Hero` in `HeroPanel` to another 
  hero's reference, that change would not flow back to `HeroJobBoard`. However, if we'd alter one or more properties of the `Hero`
  instance received from the parent &mdash; since `Hero` is an object &mdash;, that modification would flow back to the parent.
  
  ### Using `@Input`
  
  `Input` is defined in the core module of Angular, and we need to import it so that we can use it:
  
+makeExample('component-communication/ts/app/invite-heroes/hero-panel.ts', 'import', null, {blk: /(Input)/g})

:marked
  `@Input()` always must be used with parentheses:

+makeExample('component-communication/ts/app/invite-heroes/hero-panel.ts', 'input-def', null, {pnk: /(@Input\(\))/g})

:marked
.alert.is-critical
  :marked
    It's easy to forget the parentheses. Our application fails mysteriously if we do.
:marked
  Instead of using the `@Input()` annotation, we can use the `inputs` property of the `@Component` configuration object to specify input properties.

  Using the alternative method, we could have defined the `hero` input property this way:
  
code-example(format="linenums" language="javascript").
  @Component({
    inputs: ['hero']
  })
  export class HeroPanel {
    hero: Hero;
  }

:marked
.alert.is-helpful
  :marked
    In this chapter, we will always use the `@Input()` annotation.
:marked
  ### The convenience of input data binding
  
  The change detection mechanism of Angular makes input data binding easy-to-use. We can utilize the input property values in expressions, too,
  and it makes displaying data simple.
  
  We have already implemented the functionality behind the __Invite heroes__ function with input data binding. The same mechanism allows us
  to implement announcing jobs. As the altered definition of `HeroPanel` shows, now it has another input property, `request`, which has two
  occurrences within the template:

+makeExample('component-communication/ts/app/send-job-request/hero-panel.ts', 'component', 'send-job-request/hero-panel.ts (extract)', {pnk: /(&quot;request&quot;|{{request \|\|.*\}\})/g})

:marked
  As the value of `request` changes, the value of the `class` attribute changes, too, as well as the text of the `<h4>` tag through the 
  `request || 'No job announced'` expression. We simply add the `request` assignment to the `HeroJobBoard` template:
  
+makeExample('component-communication/ts/app/send-job-request/job-board-template.html', 'input-binding', 'send-job-request/job-board-template.html (extract)', {pnk: /(\[request\])/g})
:marked
  After inviting heroes, clicking the **Ask** button invokes `announceJob()`:
+makeExample('component-communication/ts/app/send-job-request/job-board-template.html', 'send', 'send-job-request/job-board-template.html (extract)')

:marked
  The `announceJob()` method is as simple as we expect:
  
+makeExample('component-communication/ts/app/send-job-request/hero-job-board.ts', null, 'send-job-request/hero-job-board.ts', {pnk: /(announceJob\(\))/g})

:marked
.alert.is-helpful
  :marked
    We can access this sample through the `Send Job Request` link.

:marked
  When we run the sample, we can check how the new job request is propagated to all `HeroPanel` instances:

figure.image-display
  img(src="/resources/images/devguide/component-communication/send-job-request-ui.png" alt="Job request is sent")
  
:marked
  In this sample, heroes do not have a way to accept a job. Thinking in property binding, we could have passed an object to the child 
  component, which has a callback method that the child could use to sign it undertakes the job. However, that would be hacky.
  
  Child components don't use property binding to communicate with their parents. They can talk to their parents with _events_.
  
  ## #2: Child to parent communication with event emitting
  
  Input property binding is an easy-to-use technique that works great in most parent-to-child communication scenarios. As the expression bound to
  the input property changes, the modification immediately propagates to all children. At first we may think that this mechanism could be
  applied in the opposite direction, to send data from a child to its parent.
  
  _Angular does not implement input data binding in this direction._ It is a deliberate design decision. Angular was designed with 
  _unidirectional data flow_ in mind.
  
  As we already said, a child can communicate with its parent via events.
  
  ### Establish output event binding
  
  To set up output event emitting, we need to carry out these steps:
  1. Create a child property that returns an `EventEmitter`
  1. Declare it to be a public _output_ property
  1. Bind that property to a parent component event handler
  
  The Hero Job Board application uses output event binding to sign that a hero undertakes the announced job. The `HeroPanel` component declares 
  an output property as a type of `EventEmitter`, through which &mdash; as the type name suggests &mdash; it can emit an event. The parent 
  `HeroJobBoard` component can use the output property to attach an event handler to that particular event.
  
  `HeroPanel` declares the `onJobTaken` output event property, as the `@Output` decorator indicates:
  
+makeExample('component-communication/ts/app/take-job-event/hero-panel.ts', 'component', 'take-job-event/hero-panel.ts (extract)', {pnk: /(@Output\(\)|takeJob\(\)|onJobTaken\.emit)/g})

:marked
  The `takeJob()` method invokes the `emit()` method of `onJobTaken`, and passes the `hero` assigned to this `HeroPanel`. 
  The parameter of `emit()` is the argument of the event emitted.
  
  To use `@Output()` and `EventEmitter`, `HeroPanel` needs to import them:
  
+makeExample('component-communication/ts/app/take-job-event/hero-panel.ts', 'import', null, {blk: /(Output|EventEmitter)/g})

:marked
  Now our `HeroPanel` is ready to emit its event. `HeroJobBoard` attaches its `heroTakesJob()` event handler method to the `onJobTaken` output
  event of `HeroPanel` using the output property binding syntax &mdash; wrapping the name of the output property, `onJobTaken`, into parentheses.
  The output property binding expression passes the `$event` identifier &mdash; that represents the argument of the emitted event &mdash; to the handler method:
  
+makeExample('component-communication/ts/app/take-job-event/job-board-template.html', 'event-binding', 'take-job-event/job-board-template.html (extract)', {pnk: /(onJobTaken)/g} )
  
:marked
  The event argument is the `hero` property value of `HeroPanel` that is passed to the `emit()` method of the `EventEmitter` instance beyond
  `onJobTaken`. `HeroJobBoard` receives the `Hero` instance that undertakes the job, and adds it to its `respondingHeroes` array.
  
+makeExample('component-communication/ts/app/take-job-event/hero-job-board.ts', 'announce', 'take-job-event/hero-job-board.ts', {pnk: /(\(onJobTaken\))/g, blk: /(heroTakesJob\(hero: Hero\))/g})

:marked
  With output event binding, we established this communication structure from `HeroPanel` children to `HeroJobBoard`:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/child-to-parent.png" alt="Output event binding")
  
.alert.is-helpful
  :marked
    We can access this sample through the `Take Job` link.

:marked
  Now, we can invite heroes, announce job requests, and our heroes can opt to undertake the job. The `HeroJobBoard` component lists responding
  heroes in the UI:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/take-job-ui.png" alt="Hero undertakes job")
  
:marked
  ### Using `@Output`
  
.alert.is-critical
  :marked
    **`@Output()` always must be used with parentheses.** If we forget about it, our application fails inscrutably.
  
:marked
  Instead of decorating properties with the `@Output()` annotation, `@Component()` can be used to define output properties.
  We could have declared that `onJobTaken` is an output property by setting up the `outputs` property of `@Component`:
  
code-example(format="linenums" language="javascript").
  @Component({
    inputs: ['hero', 'request'],
    outputs: ['onJobTaken']
  })
  export class HeroPanel {
    hero: Hero;
    request: string;
    onJobTaken = new EventEmitter<Hero>();
  }

:marked
  ### Event arguments
  
  A child component can easily identify its parent during parent-to-child communication, as it has exactly one parent. Thus when a parent 
  sets an input property, the child exactly knows the source. However, when a parent component attaches an event handler method to an
  output event of its child components, it needs to take into account that messages may be received from multiple children. It does not means
  that the parent needs to know which of its children sends the message: nonetheless, the parent needs to know how to process the message, and
  it may depend on its source, the child that sends it.
  
  When we pass arguments to events, these arguments should contain all information the parent needs to know to process the child components'
  messages properly. We can use the non-generic `EventEmitter` type that allows using any type of event arguments. However, we'd better use
  events with well-defined arguments that can be represented with strong TypeScript types.
  
.alert.is-helpful
  :marked
    Angular encourages us to use strong event argument types whenever it's possible, because it allows creating more maintainable and
    less error-prone code.
  
:marked
  ## #3: Duplex parent/child communication through a service object
  
  When we use a hierarchy of application components, we do it for the sake of sharing the responsibilities among them. Each component manages its own state and
  represents it in the UI, and they communicate with each other to implement the functionality of the app. While it is a great thing that each 
  component can manage the state of their own UI, managing the UI logic often flows through multiple component types including parent and child components,
  often may involve more than two levels of the component hierarchy.
  
  Due to its distributed nature, it may be difficult to follow and maintain the flow of UI logic. Outsourcing this logic into a separate service may help
  the visibility and maintainability of this flow. Instead of parent and child components communicating with each other in both directions, each of 
  them communicates only with an intermediary service.
  
  ### Create `JobService`
  
  In this section, we refactor our `HeroJobBoard` and `HeroPanel` components, and move the UI workflow logic into a new service, `JobService`.
  Instead of communicating directly with each other, `HeroJobBoard` and `HeroPanel` communicates with `JobService`:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/job-service-communication.png" alt="JobService communication")
  
:marked
  `JobService` is composed from read-only properties, methods and events to protect the autonomy of the service. We move all state information that
  supports the UI workflow from `HeroJobBoard` and `HeroPanel` into `JobService`:
  
+makeExample('component-communication/ts/app/assign-job/job-service.ts', null, 'assign-job/job-service.ts')

:marked
  We added the `@Injectable()` annotation is to the service, because TypeScript only generates metadata for classes that have a decorator.
  We use dependency injection to let `HeroJobBoard` and `HeroPanel` to access `JobService`, and dependency injection needs metadata.
  
  The service provides only read-only properties (through getters accessing private members) so that we can avoid accidentally changing property values.
  When a component needs to change the state of the workflow, it can make it only through invoking `JobService` methods. Components need to be
  notified when something changed so that they can update the state of the UI snippet they are responsible for. `JobService` emits events
  for this purpose.
  
.alert.is-helpful
  :marked
    Using read-only properties is a question of architectural and programming style, we prefer using it, as it makes the service object
    more robust. Whether this style is used or not, it does not change the way we can establish inter-component communication
    through an intermediary service.
  
:marked
  ### Use `JobService`
  
  To make `JobService` available for `HeroJobBoard` and `HeroPanel`, we inject it into those components through their constructors.
  For a moment, let's forget about how this works, and let's focus about how the components use `JobService`. `HeroJobBoard` utilizes
  `JobService` this way:

+makeExample('component-communication/ts/app/assign-job/hero-job-board.ts', 'component', 'assign-job/hero-job-board.ts (extract)', {blk: /(private jobService: JobService)/g})

:marked
  We can observe that now `HeroJobBoard` does not store any relevant information about the workflow state, it obtains this data from
  `JobService` &mdash; through accessing its properties via `this.jobService`. The only state information it stores, `newRequest` contains
  only the local state of `HeroJobBoard`.
  
  `HeroPanel` uses `JobService` similarly:
  
+makeExample('component-communication/ts/app/assign-job/hero-panel.ts', 'component', 'assign-job/hero-panel.ts (extract)', {blk: /(private jobService: JobService)/g})

:marked
  We can observe that `request` is not an input property anymore, its value is set by the event handler of the `jobAssigned` event. Because we cannot 
  establish output event binding between `HeroPanel` and `JobService`, as `JobService` is not a parent component of `HeroPanel`, in the constructor 
  we need to subscribe to the `jobAnnounced` and `jobAssigned` events through the `jobAnnounced.subscribe()` and `jobAssigned.subscribe()` method 
  invocations, respectively. The `subscribe()` method receives the event handler function as its argument.
  
  ### Inject `JobService` into the components
  
  Now there is only one piece of information missing so that we can understand how this inter-component communication scenario works: we need to
  know how `JobService` is injected into `HeroJobBoard` and its `HeroPanel` children. Evidently, all components must use the very same 
  `JobService` instance; otherwise the UI workflow would not work.
  
  Angular dependency injection makes it very simple to deal with this scenario. We need to pass a single `JobService` instance to `HeroJobBoard`,
  and let the the framework do its work. Because all `HeroPanel` instances are the children of the single `HeroJobBoard`, the framework sets up
  injectors so that the very same `JobService` instance is injected into the constructor of all `HeroPanel` instances. Eventually, every
  component shares the same `JobService` instance:
  
+makeExample('component-communication/ts/app/assign-job/hero-job-board.ts', 'annotation', 'assign-job/hero-job-board.ts (extract)', {blk: /(providers: \[JobService\])/g})

.alert.is-helpful
  :marked
    We can access this sample through the `Assign Job` link.

:marked
  Now, our app is fully functional, now we can not only invite heroes and let them take the job, but the person in can also assign it to a hero:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/app-ui-snapshot.png" alt="UI in action")
  
:marked
  ## #4: Communication among unrelated components via a message bus
  
  Not only parent and child components need to communicate, but often unrelated components &mdash; which are in different branches of the
  component hierarchy &mdash;, too. Although in this situations components cannot use simple declarative techniques such as input data binding and
  output event emitting; with Angular's dependency injection, the communicating parties can easily get together.
  
  ### Create a message bus
  
  In this section, we are going to build a very simple message bus that allows `HeroJobBoard` and `HeroPanel` to send text messages that can be listened to.
  We won't use this message but to let `HeroJobBoard` and `HeroPanel` talk to each other, but we create a `MessageBoard` component that can
  display these messages independently from which component they arrive from. In this communication scenario, all communicating parties are unrelated
  to each other:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/message-board-communication.png" alt="MessageBoard components")
  
:marked
  The `MessageBus` service is very simple. It provides the `broadcastMessage` method that logs the text message and immediately emits a `messageReceived` event:
  
+makeExample('component-communication/ts/app/message-board/message-bus.ts', 'component', 'message-board/message-bus.ts')

:marked
  ### Use `MessageBus`
  
  We have another new component in this scenario, it is `MessageBoard`. It's template is pretty simple:
  
+makeExample('component-communication/ts/app/message-board/message-board-template.html', null, 'message-board/message-board-template.html')

:marked
  It listens to the messages emitted by `MessageBus` through its `messagesReceived` event. 
  `MessageBoard` gets the `MessageBus` through constructor injection, and &mdash; as we already learned &mdash; it subscibes to the event so that it can handle it:
  
+makeExample('component-communication/ts/app/message-board/message-board.ts', 'class', 'message-board/message-board.ts', {blk: /(private messageBus: MessageBus)/g})

:marked
  The `HeroJobBoard` and `HeroPanel` components send messages, thus they need get a `MessageBus` instance in their constructors so that they can utilize it:
  
code-example(format="linenums" language="javascript").
  export class HeroJobBoard {
    constructor(
      private jobService: JobService,
      private messageBus: MessageBus) {
    }
    // ...
  }
  
  // ...
  
  export class HeroPanel {
    constructor(
      private jobService: JobService,
      private messageBus: MessageBus) {
        // ...
    }
      // ...
  }

:marked
  Evidently, we need to modify `HeroJobBoard` and `HeroPanel` so that they send messages when something interesting goes on &mdash; ie. heroes are invited, a new job
  is announced, a hero takes a job, or the job is assigned to a hero. It's easy to imagine how it's done, for the sake of brevity, we do not list the modified 
  code of these components.
  
  ### Make the components work together
  
  We must take care that `HeroJobBoard`, `MessageBoard` and all `HeroPanel` instances use the very same `MessageBus` instance; otherwise 
  these components cannot communicate with each other. When we inject a `MessageBus` instance into `HeroJobBoard`, we can be sure that all
  `HeroPanel` instances will use that instance &mdash; as we already saw in in the previous scenario &mdash; because of the parent-child
  relationship between `HeroJobBoard` and `HeroPanel`.
  
  Nonetheless, `MessageBoard` is a totally unrelated component to `HeroJobBoard`&mdash; and to the others. To ensure that all communicating
  componnents use the same `MessageBus` instance, we create one in the `message-bus` module, and export it:
  
+makeExample('component-communication/ts/app/message-board/message-bus.ts', 'export', 'message-board/message-bus.ts (extract)')

:marked
  We must use the `@Component` configuration object for both `HeroJobBoard` and `MessageBoard` to use `theMessageBus`:
  
+makeExample('component-communication/ts/app/message-board/hero-job-board.ts', 'component', 'message-board/hero-job-board.ts (extract)', {blk: /(providers:|MessageBus|theMessageBus)/g})
+makeExample('component-communication/ts/app/message-board/message-board.ts', 'component', 'message-board/message-board.ts (extract)', {blk: /(providers:|MessageBus|theMessageBus)/g})

.alert.is-helpful
  :marked
    We can access this sample through the `Message Board` link.

:marked
  Now, we put together all pieces to check how the message bus works:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/message-board-ui.png" alt="MessageBoard in action")
  
:marked
  ## #5: Parent to child communication where children are transposed in &mdash; using `@ContentChildren`
  
  There are situations, when a parent component cannot determine the set of its child components on its own, because the collection of its children is managed
  by an external entity. However, even in this case, the parent needs to communicate with each children. How can the parent establish the communication channel 
  to its children? Angular provides several mechanism to achieve this, here we show the usage of the `@ContentChildren` annotation.
  
  In the previous scenarios, the `HeroJobBoard` component managed the collection of heroes to invite this way:
  
+makeExample('component-communication/ts/fragments/heroes-to-invite.ts', null, null, {pnk: /(invitedHeroes)/g, blk: /(Hero\.heroes)/g})

:marked
  `HeroJobBoard` obtained the collection of heroes from the `heroes` static property of the `Hero` class. This solution was pretty useful for demonstration,
  but it does not refelect the real life. In a real application, the list of heroes is probably retrieved from the backend.
  
  Let's play with the idea &mdash; and it's seems realistic &mdash; that the list of heroes to invite is managed outside of `HeroJobBoard`, and even it
  changes while we use the app. The Hero Job Board application's logic requires that by the time we click the **Invite heroes** button, we need to know 
  the list of heroes to invite, so that the corresponding `HeroPanel` components could be nested into `HeroJobBoard`.
  
  For the sake of simplicity, we declare the list of heroes to invite as the content of `HeroJobBoard`:
  
+makeExample('component-communication/ts/app/take-job-contentchildren/job-board-with-content.ts', null, 'take-job-contentchildren/job-board-with-content.ts', {blk: /(HeroCrm)/g})

:marked
.alert.is-helpful
  :marked
    We need a component that can be used as the one to be the root component displayed by `router-outlet` we use in this example &mdash; that is why we
    use `JobBoardWithContent`. Of course, we set up the routing configuration for this scenario path accordingly.
:marked
  Here, we imitate that hero information is coming from our Hero CRM system, and each hero is represented by a `hero-crm` entity. Just for the sake of
  demonstration, we add two `hero-crm` tags deliberately with markup. `HeroCrm` could be a standard component, but we implement it as a directive &mdash; 
  a component without a view and internal logic &mdash; it only holds data:
  
+makeExample('component-communication/ts/app/take-job-contentchildren/hero-crm.ts', null, 'take-job-contentchildren/hero-crm.ts')

:marked
  Both the `id` and `name` property is decorated with `@Input()` so that we can use input data binding in `JobBoardWithContent` &mdash; 
  as we already learned it in the first scenario.
  
  ### Add `@ContentChildren`

  Now, our task is to inject the list of heroes into `HeroJobBoard` so that we can create the corresponding `HeroPanel` components. We are going to use
  the `@ContentChildren` annotation of Angular. We decorate a component property with `@ContentChildren(C)`, and set the type of the property as `QueryList<C>`,
  where `C` represents the type of the children. Here is how we use this decorator with `HeroJobBoard`:
  
+makeExample('component-communication/ts/fragments/heroes-to-invite-2.ts', null, 'take-job-contentchildren/hero-job-board.ts (extract)', {blk: /(@ContentChildren\(HeroCrm\)|QueryList&lt;HeroCrm&gt;)/g, pnk: /(heroesToInvite)/g})

:marked
  When `HeroJobBoard` is instantiated, the framework assigns a `QueryList<HeroCrm>` instance to `heroesToInvite`. At this moment this list is empty.
  `QueryList` observes the changes of the parent component's content, updates its content accordingly. Changes in `QueryList`'s content are observed
  by change detection, and trigger re-rendering, if necessary.
  
  When the **Invite heroes** button is clicked, `inviteHeroes()` copies the content of `heroesToInvite` into `heroesInvited`.
  
.alert.is-helpful
  :marked
    The `inviteHeros()` method uses the `toArray()` method of `QueryList` to convert the `QueryList<HeroCrm>` object to a `Hero[]`. Because the shape of
    `HeroCrm` is compatible with `Hero` &mdash; they have the same properties &mdash; TypeScript allows this implicit conversion.
    
    The component lifecycle has an explicit point when the content of `HeroJobBoard` is collected by the framework, and then `heroesToInvite` is updated. You can hook into
    this lifecycle event by defining the `ngAfterContentInit()` method, and carry out any additional setup you may need to use the collection of children.

:marked
  We do not need to change any other components to complete our task. When the app is running, and the **Invite heroes** button is clicked, we 
  can see 8 heroes instead of the 6 we saw in the previous scenarios:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/with-contentchildren-ui.png" alt="Heroes by @ContentChildren")
  
+makeExample('component-communication/ts/fragments/heroes-to-invite-2.ts', null, 'take-job-contentchildren/hero-job-board.ts (extract)', {blk: /(@ContentChildren\(HeroCrm\)|QueryList&lt;HeroCrm&gt;)/g, pnk: /(heroesToInvite)/g})

:marked
  The `JobBoardWithContent` component nests 8 `hero-crm` children: 6 coming from `Hero.heroes`, and 2 others (Dynama and Magma) added with direct markup.
  
  ### A few additional comments about `@ContentChildren`
  
  * `@ContentChildren` provides a mechanism for a parent to collect its children defined as content. We can use _all the communication techniques between the
  parent and its children_ (in both direction) you already learned in this chapter.
  * Components can have multiple `@ContentChildren` properties witch different child types.
  * `QueryList` has a `changes` property that provides a `subscribes()` method to be notified about changes in the content children.
  
  ## Conclusion
  
  Angular provides great communication mechanisms among components within an application. If we have components within the same tree or subtree,
  we have parent and child components, and can use these methods:
  * **Parent to child**: data binding with using one or more `@Input()` propery in the child component, the values of which can be assigned in the parent's 
  template.
  * **Child to parent**: event binding with using one or more `@Output()` properties (`EventEmitter` instances) in the child component, the event handlers 
  of which can be assigned in the parent's template.
  
  If we have have unrelated components that are in separate subtrees, they can communicate **through intermediary components**, such as services:
  * The same intermediary component instance can be injected into the the communicating parties. 
  * The parties utilize the intermediary component, 
    * they can access its properties, 
    * invoke its methods,
    * and subscribe to its events.
    
  As we discussed, intermediary components are great alternatives for parent to child, and child to parent communication, too. With the help of 
  `@ContentChildren` we can transpose children into their parent, and utilize the parent-to-child or child-to-parent communication techniques we 
  already learned.

  In this chapter, we identified a few issues Angular developers should be aware of when designing and implementing inter-component communication:
  Using a direct reference to the parent component in a child to parent communication scenario &mdash; ie. by passing down the reference
  through data binding &mdash; is an **antipattern**. This may break Angular's data flow, and make our app fragile.
